---
title: "Encode: finished and In progress"
output: html_notebook
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file()) # Set WD to Root
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
library(tidyverse)

```


# Encode Function


## Complex version

```{r encode_moodle}
encode_moodle <- function(df_cleaned, 
                          state = c("Finished", "In progress"),
                          encode = c(1,0),
                          choose_encode = c("max", "min", "all"),
                          choose_time = c("first", "last", "all")
                          ) {
  
  if(length(state) != length(encode)) stop("`state` and `encode` must have same length", call. = F)
  
  choose_encode <- rlang::arg_match(choose_encode)
  choose_time <- rlang::arg_match(choose_time)
  
  df_encoded <- df_cleaned %>% 
    dplyr::mutate(Encode = encoder(State, state, encode), .after = "State")
  
    # "max", "min", "all" = maximum, minimum or all of encoding 
    filt_expr_1 <- switch (choose_encode,
                    "max" = {rlang::expr(Encode == max(Encode))},
                    "min" = {rlang::expr(Encode == min(Encode))},
                    "all" = {rlang::expr(Encode == Encode)},
                       stop("Must be one of `max`, `min`, `all`", 
                            call. = F)
    )
    # "first", "last" = first or last attempt  
    filt_expr_2 <- switch (choose_time,
                    "first" = {rlang::expr(Started == min(Started))},
                    "last" = {rlang::expr(Started == max(Started))},
                    "all" = {rlang::expr(Started == Started)},
                       stop("Must be one of `max`, `min`, `all`", 
                            call. = F)
    )
    
 df_encoded %>% 
    dplyr::group_by(Name, ID) %>% 
    dplyr::filter(!!filt_expr_1) %>% 
    dplyr::filter(!!filt_expr_2) %>% 
    dplyr::ungroup()
  
}

f2_mgrad_raw %>% 
  clean_moodle() %>% 
  encode_moodle(choose_encode = "max", choose_time = "all") %>% 
  filter(Encode == 0) %>% 
  count(Name, ID, sort = T)
```

#### Student who "In progress" but eventually finished

```{r}
f2_mgrad_raw %>% 
  clean_moodle() %>% 
  encode_moodle(choose_encode = "min", choose_time = "all") %>% 
  
  filter(Encode == 0) %>% 
  count(Name, ID, sort = T)
```

#### Students who "In progress" and Never finished

```{r}
f2_mgrad_raw %>% 
  clean_moodle() %>% 
  encode_moodle(choose_encode = "max", choose_time = "all") %>% 
  
  filter(Encode == 0) %>% 
  count(Name, ID, sort = T)
```



## Simple version

```{r encode_moodle2}
encode_moodle2 <- function(df_cleaned, 
                          state = c("Finished", "In progress"),
                          encode = c(1,0),
                          choose_attempt = c("max", "min", "first", "last", "all")
                          ) {
  
  if(length(state) != length(encode)) stop("`state` and `encode` must have same length", call. = F)
  choose_attempt <- match.arg(choose_attempt)
  
  df_encoded <- df_cleaned %>% 
    dplyr::mutate(Encode = encoder(State, state, encode), .after = "State")
  
  # Filter attempt: "all" = not filter 
  if(choose_attempt == "all") return(df_encoded)
    # "max", "min"= the first maximum or minimum of encode
    # "first", "last" = first or last attempt  
    filt_expr <- switch (choose_attempt,
                    "max" = {rlang::expr(Encode == max(Encode) & Started == min(Started))},
                    "min" = {rlang::expr(Encode == min(Encode) & Started == min(Started))},
                    "first" = {rlang::expr(Started == min(Started))},
                    "last" = {rlang::expr(Started == max(Started))},
                       stop("Must be one of `max`, `min`, `first`, `last`, `all`", 
                            call. = F)
  )
    
 df_encoded %>% 
    dplyr::group_by(Name, ID) %>% 
    dplyr::filter(!!filt_expr) %>% 
    dplyr::ungroup()
  
}

tech_grad_df2_raw_clean %>% encode_moodle2()

tm_mgrad_raw %>% 
  clean_moodle() %>% 
  encode_moodle2(choose_attempt = "max")
```

### "max" & "min"

If "max" the max encoding of each student is chosen then if multiple max is found
the first attempt of that max is returned

If "min" the min encoding of each student is chosen then if multiple min is found
the first attempt of that min is returned


### Encode Idea

choose_encode = max, min, all
choose_time = first, last, all 

Total 9 combinations


eg. first max = first time that student get max encoding

too complicated ?

### Vector Encoding

```{r encoder}
encoder <- function(x, # Any vector
                    match, 
                    encode = match # Encode that pair with match
                    ) {
  
  if(length(match) != length(encode)) stop("`match` and `encode` must have same length", call. = F)
  
  df <- data.frame(match = match, encode = encode)
  index <- match(x, df$match)
  
  df$encode[index]
  
}

c("a","b","d") %>% encoder(c("a","b","c"), c("A","B","C"))
```



Similar to this

```{r}
tm_test1 <- tm_mgrad_raw %>% 
  clean_moodle() %>% 
  select(Name, ID, State, Started) %>% 
  mutate(Encode = case_when(State == "Finished" ~ 1,
                            State == "In progress" ~ 0)) %>% 
  group_by(Name, ID) %>% 
  filter( !!expr(Encode == max(Encode) & Started == min(Started)) ) 
```


```{r}
tm_test2 <- tm_mgrad_raw %>% 
  clean_moodle() %>% 
  select(Name, ID, State, Started) %>% 
  mutate(Encode = case_when(State == "Finished" ~ 1,
                            State == "In progress" ~ 0)) %>% 
  group_by(Name, ID) %>% 
  filter( !!expr(Encode == max(Encode))) %>% 
  filter(Started == min(Started))
```


```{r}
identical(tm_test1, tm_test2)
```

```{r}
testthat::test_that("filter with & in one line or separte filter is not difference",
  testthat::expect_identical(tm_test1, tm_test2)
)
```

