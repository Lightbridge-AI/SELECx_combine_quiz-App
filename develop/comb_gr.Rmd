---
title: "Combine Grade"
output: html_notebook
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file()) # Set WD to Root
library(tidyverse)
library(testthat)
```


combine_grades
combine_grades.list
combine_grades.data.frame



# Generic: Combine Grade


`new_max_grade`
-  list method: NULL = no adjust grade, or Numeric vector same length as length of list 
-  DF method: NULL = no adjust grade, or Numeric vector of length 1 


```{r combine_grades}
combine_grades <- function(data,
                           # Clean
                           extract_id_from = c("Email address", 
                                           "Institution", "Department"),
                           id_regex = ".*", 
                           sep_name = " ", # Separate First name and Surname
                           # Adjust Grade
                           new_max_grade = NULL, 
                           ### NULL = no adjust,
                           ### (DF method): length 1 Numeric
                           ### (list method): Numeric vector same length as length `data` 
                           round_digits = 3, # NULL = no round
                           # Filter Grades
                           choose_grade = c("max", "min", "mean", "all"),
                           choose_time = c("first", "last", "all"),
                           force_grade = F,
                           sep_col = "_" # Separation for State and Grade column names
                           ) {
  
  UseMethod("combine_grades")
  
}

combine_grades(tm_mgrad_raw, new_max_grade = 10)
combine_grades(tech_grad_ls_raw, new_max_grade = c(10,20,30), 
               sep_col = ":", id_regex = "[:digit:]+", choose_grade = "mean")


moodleQuiz::combine_grades(tech_grad_ls_raw) %>% names()
moodleQuiz::combine_grades(tech_resp_df2_raw)

moodleQuiz::combine_grades(tm_mgrad_raw, choose_grade = "mean", choose_time = "all")
```

```{r}
moodleQuiz::combine_grades(int_nerv_resp)
combine_grades(ncv_po_resp_raw)

combine_grades(tm_mgrad_raw, choose_grade = "mean")

moodleQuiz:::filter_grades_moodle

moodleQuiz::combine_grades(tm_mgrad_raw, choose_grade = "mean")
```


# List method


```{r combine_grades.list}
combine_grades.list <- function(data,
                                # Clean
                               extract_id_from = c("Email address", 
                                           "Institution", "Department"),
                                id_regex = ".*", 
                                sep_name = " ", # Separate First name and Surname
                                # Adjust Grade
                                new_max_grade = NULL,
                                round_digits = 3, # If NULL = no round
                                # Filter Grades
                                choose_grade = c("max", "min", "mean", "all"),
                                choose_time = c("first", "last", "all"),
                                force_grade = F,
                                sep_col = "_" # Separation for State and Grade column names

                                ) {
  
    if(!is_named_list_data.frame(data)) stop("`data` must be named list of data.frame", call. = F)
  is_data_rep <- purrr::every(data, is_report)
  if(!is_data_rep) stop("Elements of `data` must be Moodle Quiz report",call. = F)
  
  has_grade_col <- purrr::every(data, ~is_regex_in_names(.x, "Grade"))
  if(!has_grade_col) stop("Elements of `data` must have 'Grade' column.", call. = F)
  
  is_nyg_err <- all(!force_grade, purrr::every(data, is_some_grade_nyg))
  if(is_nyg_err) stop("Some students are 'Not yet graded'. If you want to grade anyway, choose `force_grade = TRUE`.", call. = F)
  
  # If new_max_grade = NULL
  if(is.null(new_max_grade)){
    new_max_grade <- replicate(length(data), NULL)
    tot_max_grade <- purrr::map_dbl(data, get_max_grade) %>% sum()
  
  }else{
    # If supply new_max_grade as numeric vector
    if(length(new_max_grade) != length(data)) stop("length of `new_max_grade` must equal to length of `data`", call. = F)
    tot_max_grade <- sum(new_max_grade)
  }
    
  data_ls <- data %>% 
      purrr::map2(.y = new_max_grade,
        ~combine_grades.data.frame(.x, 
                                   extract_id_from = extract_id_from,
                                   id_regex = id_regex, 
                                   sep_name = sep_name, 
                                   new_max_grade = .y, 
                                   round_digits = round_digits, 
                                   choose_grade = choose_grade, 
                                   choose_time = choose_time,
                                   force_grade = force_grade
                                   )
      )
  
  data_ls %>% 
    purrr::map(~dplyr::select(.x, Name, ID, State, tidyselect::starts_with("G"))) %>% 
    rename_with_ls_df_names(tidyselect::starts_with("S"), sep = sep_col) %>% 
    rename_with_ls_df_names(tidyselect::starts_with("G"), sep = sep_col) %>% 
    # Join
    purrr::reduce(dplyr::full_join, by = c("Name", "ID")) %>% 
    dplyr::rowwise() %>% 
    dplyr::mutate("Total_{tot_max_grade}" := sum(
      dplyr::c_across(tidyselect::vars_select_helpers$where(is.numeric)), na.rm = T)
      ) %>% 
    dplyr::ungroup()

}

tech_grad_ls_raw %>% combine_grades.list(new_max_grade = NULL)
tech_grad_ls_raw %>% combine_grades.list(new_max_grade = c(1,2,3))
```




```{r}
combine_grades.list(list(a = int_nerv_resp) )
```



### Test: list

```{r test combine_grades.list}
test_that("combine_grades.list",{
  
  comb_no_adj <- combine_grades.list(tech_grad_ls_raw, new_max_grade = NULL) 
  comb_adj <- combine_grades.list(tech_grad_ls_raw, new_max_grade = c(1,2,3))
  
  expect_s3_class(comb_no_adj, "data.frame")
  expect_s3_class(comb_adj, "data.frame")
  
  expect_error(combine_grades.list(iris), "must be named list of data.frame")
  expect_error(combine_grades.list(list(i = iris)), "must be Moodle Quiz report")
  expect_error(combine_grades.list(list(a = int_nerv_resp) ), "must have 'Grade' column")
  expect_error(combine_grades.list(list(t = tech_nograd_df1)), 
               "'Not yet graded'")
  expect_error(combine_grades.list(tech_grad_ls_raw, new_max_grade = c(10)), 
               "`new_max_grade` must equal to length of `data`")
  # IF force grade: Override Error
  expect_s3_class(combine_grades.list(list(t = tech_nograd_df1), force_grade = T), 
                 "data.frame")
})

```

Error msg

```{r}
combine_grades.list(iris)
combine_grades.list(list(i = iris)) 
combine_grades(tech_nograd_df1, force_grade = T)
combine_grades.list(list(t = tech_nograd_df1))
combine_grades.list(list(t = tech_nograd_df1), force_grade = T)
```

#### Example

```{r}
new_wt_grades <- c(10,40,50)
new_wt_grades_tot <- sum(new_wt_grades)

tech_grad_ls_raw %>% 
  map2(.y = new_wt_grades,
    ~combine_grades.data.frame(.x, new_max_grade = .y, choose_grade = "max")
    ) %>% 
  map(~select(.x, Name, ID, State, starts_with("G"))) %>% 
  
  rename_with_ls_df_names(starts_with("S")) %>% 
  rename_with_ls_df_names(starts_with("G")) %>% 
  
  reduce(full_join, by = c("Name", "ID")) %>% 
  rowwise() %>% 
  mutate("Total_{new_wt_grades_tot}" := sum(c_across(where(is.numeric)))) %>% 
  ungroup()
```


# DF method

data = any moodle quiz report, but must have all numeric in Grades column

choose_grade = max, min, mean, all
choose_time = first, last, all



```{r combine_grades.data.frame}
combine_grades.data.frame <- function(data,
                                      # Clean
                                      extract_id_from = c("Email address", 
                                           "Institution", "Department"),
                                      id_regex = ".*", 
                                      sep_name = " ", # Separate First name and Surname
                                      # Adjust Grade
                                      new_max_grade = NULL,
                                      round_digits = 3, # If NULL = no round
                                      # Filter Grades
                                      choose_grade = c("max", "min", "mean", "all"),
                                      choose_time = c("first", "last", "all"),
                                      force_grade = F,
                                      ... # absorb sep_col arg
                                      ) {
  
  if(!is_report(data)) stop("`data` is not a Moodle Quiz report.", call. = F)
  
  has_grade_col <- is_regex_in_names(data, "Grade")
  if(!has_grade_col) stop("`data` must has 'Grade' column.", call. = F)

  is_nyg_err <- all(!force_grade, is_some_grade_nyg(data))
  if(is_nyg_err) stop("Some students are 'Not yet graded'. If you want to grade anyway, choose `force_grade = TRUE`.", call. = F)
  # Clean
  data %>% 
    clean_moodle(id_regex = id_regex, 
                 extract_id_from = extract_id_from,
                 sep_name = sep_name, force_numeric = TRUE) %>% 
  # Adjust Grade
    adj_grades_moodle(new_max_grade = new_max_grade, 
                      round_digits = round_digits) %>% 
  # Filter Grade
    filter_grades_moodle(choose_grade = choose_grade, choose_time = choose_time)
  
}

combine_grades.data.frame(tm_mgrad_raw,
                          id_regex = "[:digit:]+",
                          new_max_grade = 100, round_digits = NULL,
                          choose_grade = "max",
                          choose_time = "all") 

combine_grades.data.frame(tech_resp_df2_raw)
combine_grades.data.frame(tech_grad_df2_raw)
combine_grades.data.frame(tm_ncv_gr, extract_id_from = "Institution", force_grade = T)
```



### Test: DF

```{r test combine_grades.data.frame}
test_that("combine_grades.data.frame",{
  
  ## Output
  combine_grades.data.frame(tech_grad_df2_raw) %>% expect_s3_class("data.frame")
  combine_grades.data.frame(tech_resp_df2_raw) %>% expect_s3_class("data.frame")
  ## Error msg
  combine_grades.data.frame(iris) %>% expect_error("is not a Moodle Quiz report")
  combine_grades.data.frame(tech_nograd_df1) %>% expect_error("'Not yet graded'")
  combine_grades.data.frame(int_nerv_resp) %>% expect_error("`data` must has 'Grade' column")
  # If Force Grade; override
  expect_s3_class(combine_grades.data.frame(tech_nograd_df1, force_grade = T),
                 "data.frame")
})
```


```{r}
combine_grades.data.frame(tech_nograd_df1, force_grade = F)
```



## Adjust Grade Function

```{r adj_grades_moodle}
adj_grades_moodle <- function(data_cleaned, 
                              new_max_grade = NULL,
                              round_digits = 3 # If NULL, no round
                              ) {
  ## Check Report type
  is_resp_rep <- stringr::str_detect(names(data_cleaned), "R") %>% any()
  is_grades_rep <- stringr::str_detect(names(data_cleaned), "Q") %>% any()
  ## Symbol for Grade_xx column
  Grade_col <- names(data_cleaned) %>% stringr::str_subset("Grade") %>% rlang::sym()
  ## Old maximum Grade
  old_max_grade <- get_max_grade(data_cleaned)
  ## If not adjust grade -> New = Old 
  if(is.null(new_max_grade)){
    new_max_grade <- old_max_grade
  }
  ## Grade adjust factor
  adj_factor <- c(new_max_grade/old_max_grade) 
  ## New Grade col name
  Grade_col_new <- rlang::sym(paste0("Grade_", new_max_grade))
  # Adjust Grade (Responses Report)
  if(is_resp_rep){
  data_adj_gr <- data_cleaned %>% 
      dplyr::mutate(!!Grade_col_new := !!Grade_col * adj_factor, 
                    .keep = "unused", .after = State)
  }
  # Adjust Grade (Grades Report)
  if(is_grades_rep){
  data_adj_gr <- data_cleaned %>% 
     # Remove Old Grade_xx Column
     dplyr::select(!tidyselect::starts_with("G")) %>% 
     # Adjust New Score for Each Questions
     dplyr::mutate(dplyr::across(tidyselect::starts_with("Q"), ~.x * adj_factor)) %>% 
     # Row Sum those Questions to New Grade_xx column
     dplyr::rowwise() %>% 
     dplyr::mutate(!!Grade_col_new := sum(
       dplyr::c_across(tidyselect::starts_with("Q")), na.rm = T
       ), .after = State) %>% 
     dplyr::ungroup() 
  }
  # Round
  if(is.null(round_digits)) return(data_adj_gr)
  data_adj_gr %>% 
     dplyr::mutate(dplyr::across(
       c(tidyselect::starts_with("G"), tidyselect::starts_with("Q")), 
       ~round(.x, digits = round_digits))
       )
  
}

tm_mgrad_raw %>% clean_moodle() %>% adj_grades_moodle(new_max_grade = 10)
tech_resp_df1_raw %>% 
  clean_moodle() %>% 
  adj_grades_moodle(new_max_grade = 12, round_digits = NULL)
```

## Filter Grade function

```{r filter_grades_moodle}
filter_grades_moodle <- function(data_cleaned,
                                 choose_grade = c("max", "min", "mean", "all"),
                                 choose_time = c("first", "last", "all")
                                 ) {
  
  choose_grade <- rlang::arg_match(choose_grade)
  choose_time <- rlang::arg_match(choose_time)
  # Get Grades Column name
  Grade_col <- stringr::str_subset(names(data_cleaned), "G") %>% rlang::sym()
  
  # If "mean" compute mean score of each student (only finished attempts)
  if (choose_grade == "mean") {
    out <- data_cleaned %>%
      dplyr::filter(State == "Finished") %>%
      dplyr::group_by(Name, ID, State) %>%
      dplyr::summarise(
        dplyr::across(tidyselect::vars_select_helpers$where(is.numeric), ~ mean(.x, na.rm = T)), .groups = "keep"
      ) %>%
      dplyr::ungroup()

    return(out)
  }
  # Grouped filter by Score of each student
  filt_expr_1 <- switch (choose_grade,
    "max" = { rlang::expr(!!Grade_col == max(!!Grade_col)) },
    "min" = { rlang::expr(!!Grade_col == min(!!Grade_col))},
    "all" = { rlang::expr(!!Grade_col == !!Grade_col)},
    stop("`choose_grade` must be one of 'max', 'min', 'mean', 'all'", call. = F)
  )
  # Grouped filter by Started Time of each student
  filt_expr_2 <- switch (choose_time,
    "first" = { rlang::expr(Started == min(Started)) },
    "last" = { rlang::expr(Started == max(Started)) },
    "all" = { rlang::expr(Started == Started) },
    stop("`choose_time` must be one of 'first', 'last', 'all'", call. = F)
  )
  
  data_cleaned %>%
    dplyr::group_by(Name, ID) %>%
    dplyr::filter(!!filt_expr_1) %>%
    dplyr::filter(!!filt_expr_2) %>%
    dplyr::ungroup()

  
}

tm_mgrad_raw %>% clean_moodle() %>% filter_grades_moodle(choose_grade = "max", 
                                                         choose_time = "all")
tech_resp_df1_raw %>% clean_moodle() %>% filter_grades_moodle()
```


```{r}
tech_resp_df2_raw %>% clean_moodle() %>% names() %>% str_detect("R") 
tm_mgrad_raw %>% clean_moodle() %>% names() %>% str_detect("Q")  
```


```{r}
tm_mgrad_raw %>% clean_moodle() %>% is_grades_report()
```


```{r}
tm_mgrad_raw %>% clean_moodle() %>% get_max_grade()
```


```{r}
tech_resp_df1_raw %>%  combine_grades.data.frame()
tech_nograd_df1 %>% combine_grades.data.frame()
```


## Error Message - If Grade = "Not yet graded" 

```{r}
tech_nograd_df1 %>% 
  distinct(across(c(starts_with("G"), starts_with("Q"))))
```

```{r}
is_some_grade_nyg(tech_nograd_df1)
```


```{r}
combine_grades.data.frame(tech_nograd_df1)
```



# Example


### First Maximum Score of each students + Adjust Max Score

```{r}
new_max_grade <- c(10)

tm_mgrad_raw %>% 
  clean_moodle() %>% 
  ## Adjust Maximum Score
  mutate("Grade_12.00" = Grade_12.00 * 10/12) %>% 
  
  group_by(Name, ID) %>% 
  filter(Grade_12.00 == max(Grade_12.00)) %>% 
  filter(Started == min(Started)) %>% 
  ungroup()
```

### Detect Grade_xxx column name

```{r}
tm_mgrad_raw %>% 
  clean_moodle() %>% 
  names() %>% str_subset("Grade")
```

